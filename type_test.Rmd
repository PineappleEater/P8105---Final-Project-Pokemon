---
title: "Pokemon Type Effectiveness Analysis & Rating System"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: show
    theme: cosmo
    self_contained: true
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_dir = "reports"
    )
  })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 10,
  fig.height = 6
)
```

## 1. Load Libraries and Data

```{r libraries}
library(tidyverse)
library(knitr)
library(glue)
library(here)  # For robust path handling

set.seed(123)
theme_set(theme_minimal(base_size = 12))
```

```{r load-data}
# Load type effectiveness data
type_df <- read_csv("data/def_type_df.csv")

# Load Pokemon data
pokemon_df <- read_csv("data/pokemon_data_final_evolutions_enriched.csv")

# Restore factor levels
pokemon_df$generation <- factor(pokemon_df$generation, levels = paste0("Gen ", 1:9))
pokemon_df$category <- factor(pokemon_df$category,
  levels = c("Regular", "Legendary", "Mythical", "Paradox", "Ultra Beast")
)

cat(glue("Type matchups: {nrow(type_df)} combinations\n"))
cat(glue("Pokemon dataset: {nrow(pokemon_df)} Pokemon\n"))
```

## 2. Type Effectiveness Analysis

### 2.1 Attack Type Analysis

Which attack types have the most super-effective matchups (x2 or x4 damage)?

```{r attack-effectiveness}
# Count super-effective (x2, x4), not very effective (x0.5), and immune (x0) for each attack type
attack_stats <- type_df |>
  group_by(atk_type) |>
  summarise(
    super_effective_x4 = sum(multiplier == 4),
    super_effective = sum(multiplier == 2),
    not_effective = sum(multiplier == 0.5),
    immune = sum(multiplier == 0),
    neutral = sum(multiplier == 1),
    .groups = "drop"
  ) |>
  arrange(desc(super_effective))

kable(attack_stats, caption = "Attack Type Effectiveness (vs Single Types)")
```

```{r attack-effectiveness-scale and score}
cols_list_max <- c("super_effective_x4", "super_effective", "neutral")
cols_list_min <- c("not_effective")
attack_stats_scaled <- attack_stats |>
  mutate(
    round(across(
      all_of(cols_list_max),
      ~ .x / max(.x) 
    ),2),
    round(across(
      all_of(cols_list_min),
      ~ .x / max(.x) 
    ),2),
    immune = if_else(immune > 0, 1, 0),
    offensive_score = (
      super_effective_x4*0.2	+ super_effective*0.6 + neutral*0.2	- not_effective*0.15)*100 - immune*10,
    offensive_score_scaled = round(
      (offensive_score - min(offensive_score)) /
      (max(offensive_score) - min(offensive_score)) * 100,
    2)) |> 
  arrange(desc(offensive_score_scaled))


kable(attack_stats_scaled, caption = "Attack Type Effectiveness")
```

### 2.3 Defense Type Analysis

Which defense types have the most resistances (x0.5, x0.25, x0) and fewest weaknesses (x2, x4)?

```{r defense-effectiveness}
# Calculate defense effectiveness for single types
defense_stats <- type_df |>
  group_by(def_type) |>
  summarise(
    weaknesses = sum(multiplier == 2),
    weaknesses_x4 = sum(multiplier == 4),
    strong_resistances = sum(multiplier == 0.25),
    resistances = sum(multiplier == 0.5),
    immunities = sum(multiplier == 0),
    neutral = sum(multiplier == 1),
    .groups = "drop"
  ) |>
  arrange(desc(resistances))

kable(defense_stats, caption = "Defense Type Effectiveness")
```

```{r defense-effectiveness-scale and score}
cols_list_max <- c("strong_resistances", "resistances", "neutral")
cols_list_min <- c("weaknesses_x4", "weaknesses")
def_stats_scaled <- defense_stats |>
  mutate(
    round(across(
      all_of(cols_list_max),
      ~ round(.x / max(.x),2) 
    ),2),
    across(
      all_of(cols_list_min),
      ~ round(.x / max(.x),2) 
    ),
    defense_score = (
      strong_resistances*0.2	+ resistances*0.45 + neutral*0.2	- weaknesses_x4*0.1 - weaknesses*0.05)*100 + immunities*5,
    defense_score_scaled = round(
      (defense_score - min(defense_score)) /
      (max(defense_score) - min(defense_score)) * 100,
    2)) |> 
  arrange(desc(defense_score_scaled))


kable(def_stats_scaled, caption = "Defence Type Effectiveness")
write_csv(def_stats_scaled, "data/def_stats_scaled.csv")
```


## 4. Pokemon Rating System

### 4.1 Rating Components

We develop a 100-point rating system for beginners with the following components:

1. **Efficient Stat Total (40 points)**: Raw power indicator - **Smooth S-curve mapping**
2. **Stat Distribution (60 points)**: Offensive or defensive indicator base on distribution:
  a) *Efficient attack power*(S-curve): Calculated by $max(attack, special\ attack)$ 
                                or $0.6*(attack + special\ attack)$ if they are too close - **Mixed Offense**
  b) *Durability expectations*: Calculated by $hp*\sqrt{defence*special\ defence}$
  c) *Effective speed score*(V): Calculated by $S(v) = B(v) + 0.5*D(v)$, which $v = speed$
                                            "Faster is better" $B(v)=\frac{v-v_{min}}{v_{max}-v_{min}}$
                                            "Tactical value" $D(v)=\frac{|v-v_0|}{max(v_0-v_{min},v_{max}-v_0)}$
                                                            or "Slower isn't necessarily worse"
3. **Defensive only (30+0.5*Stat Distribution point)**: Defensive type advantages
                                            

```{r rating-components}
# Smooth BST Score Calculator (40 points max)
# Uses logistic function (S-curve) for smooth transition
calc_bst_score <- function(total, atk, spatk, eff_atk) {
  # Parameters for S-curve - adjusted for higher scores
  # Midpoint at BST=450 (shifted left to give higher scores overall)
  # Steepness: gradual transition from 250-700
  L <- 40      # Maximum score
  k <- 0.015   # Steepness (increased for faster growth)
  x0 <- 450    # Inflection point (lowered to boost scores)
  bst = total - atk - spatk + eff_atk
  
  # Logistic function: L / (1 + exp(-k * (x - x0)))
  score <- L / (1 + exp(-k * (bst - x0)))
  
  # Ensure minimum of 5 points for very weak Pokemon
  return(score)
}

# Efficient attack power
calc_eff_atk <- function(atk, spatk){
  ratio <- pmin(atk, spatk) / pmax(atk, spatk)
  ifelse(ratio < 0.9, pmax(atk, spatk), 0.6*(atk + spatk))
}
# Durability expectations
calc_eff_def <- function(hp, def, spdef){
  hp * sqrt(def * spdef)
}
# Effective speed score
calc_eff_spd <- function(spd, vmin, vmax, v0 = 80){
  B <- (spd - vmin) / (vmax - vmin)
  D <- (abs(spd - v0)) / max(v0 - vmin, vmax - v0)
  B + 0.5 * D
}
# Stats Distribution (60 points)
calc_atk_score <- function(eff_atk_s, eff_def_s, eff_spd_s){
  (0.5*eff_atk_s + 0.1*eff_def_s + 0.4*eff_spd_s) * 60
}

calc_def_score <- function(eff_atk_s, eff_def_s, defense_score){
  (0.8*eff_def_s + 0.2*eff_atk_s) * 30 + 30 * defense_score/100
}

```

### 4.2 Calculate Ratings

```{r calculate-ratings}
#Give each Pokemon a Defense Type Score
TYPE_ORDER <- c(
  "Normal","Fire","Water","Electric","Grass","Ice",
  "Fighting","Poison","Ground","Flying","Psychic",
  "Bug","Rock","Ghost","Dragon","Dark","Steel","Fairy"
)

pokemon_df_score <- pokemon_df |>
  mutate(
    idx1 = match(type_1, TYPE_ORDER),
    idx2 = match(type_2, TYPE_ORDER),
    def_type = case_when(
      is.na(type_2) ~ type_1,
      TRUE ~ paste(
        TYPE_ORDER[pmin(idx1, idx2)],
        TYPE_ORDER[pmax(idx1, idx2)],
        sep = "/"
      )
    )
  ) |> 
  left_join(
    def_stats_scaled |> select(def_type, defense_score),
    by = "def_type"
  )


# Calculate rating for each Pokemon
pokemon_df_score <- pokemon_df_score |> 
  mutate(
    eff_atk = calc_eff_atk(attack, sp_atk),
    eff_def = calc_eff_def(hp, defense, sp_def),
    eff_spd = calc_eff_spd(speed, min(speed), max(speed)),
    
    eff_atk_s = eff_atk / max(eff_atk),
    eff_def_s = eff_def / max(eff_def),
    eff_spd_s = eff_spd / max(eff_spd),
    # BST Score (40 points) - Smooth S-curve
    bst_score = calc_bst_score(total, attack, sp_atk, eff_atk),
    
    # BST Score (40 points) + Stat Balance Score (60 points)
    total_atk_score = bst_score + calc_atk_score(eff_atk_s, eff_def_s, eff_spd_s),
    total_def_score = bst_score + calc_def_score(eff_atk_s, eff_def_s, defense_score)
  ) |> 
  select(dex, name, bst_score, 
         def_type, defense_score, total_def_score, 
         eff_atk, total_atk_score) 
         
         #select这段你根据分析自己看着改吧，我纯为了确定是否符合强度理解。最终其实只需要分析total_def_score和total_atk_score了，综合属性的全在total_def_score里了不需要额外分析，不过可以做total_atk_score+total_def_score找出最强宝可梦（虽然没什么参考性）。
```

